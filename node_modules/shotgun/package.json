{
  "name": "shotgun",
  "version": "2.0.0",
  "description": "Shotgun is a UI agnostic command shell. It allows you to quickly and easily write commands and plug them into the shell framework. Rather than assuming the UI, such as the Javascript console, Shotgun returns a result object that acts as a set of instructions so that any application can easily consume it.",
  "main": "./index",
  "dependencies": {
    "optimist": "~0.3.5",
    "shell-quote": "0.0.1",
    "node.extend": "~1.0.0"
  },
  "devDependencies": {
    "mocha": "*",
    "chai": "*",
    "prompt": "*"
  },
  "scripts": {
    "test": "mocha -R tap"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Chevex/node-shotgun.git"
  },
  "keywords": [
    "command",
    "line",
    "cli",
    "shell",
    "shotgun",
    "terminal",
    "prompt"
  ],
  "author": {
    "name": "Alex Ford"
  },
  "license": "Apache",
  "readmeFilename": "README.md",
  "gitHead": "812d49a1ae47cf60c945e14b0bc06542dc940d65",
  "readme": "# shotgun\r\n\r\nShotgun is a UI agnostic command shell. It allows you to quickly and easily write commands and plug them into the shell framework. Rather than assuming the UI, such as the Javascript console, shotgun returns a result object that acts as a set of instructions so that any application can easily consume it, including web applications. In fact, I took the liberty of writing a separate module called [shotgun-client](https://npmjs.org/package/shotgun-client) that makes it simple to integrate shotgun with any web application.\r\n\r\n---\r\n\r\n### Module Installation\r\n\r\n    npm install shotgun\r\n\r\n\r\n### Module Usage\r\n\r\nTo use shotgun you simply require it and create an instance of the shell.\r\n\r\n    var shotgun = require('shotgun');\r\n    var shell = new shotgun.Shell();\r\n\r\nThe shell optionally accepts a path (relative to the current working directory) to look for your custom command modules. If no directory is specified then 'cmds' is used by default. Shotgun will automatically read in and `require()` all node modules in the specified directory and it will plug them into the framework as commands as long as they expose the required properties and functions.\r\n\r\n---\r\n\r\n## Getting started using the shell.\r\n\r\nOnce you've setup shotgun and instantiated the shell you can build any UI application around it that you wish. The simplest application is just a basic console app so that's what we'll setup here.\r\n\r\n1. First you'll need to install a module to help with reading values from the console so that you can pass them into your shotgun shell.\r\n    > npm install prompt\r\n\r\n2. Next set up a basic app to continually get a value from the user.\r\n\r\n        var prompt = require('prompt');\r\n        function callback(err, val) {\r\n            if (!err && val.cmdStr) {\r\n                console.log(\"Echo: \" + val.cmdStr);\r\n            }\r\n            prompt.get('cmdStr', callback);\r\n        }\r\n        prompt.get('cmdStr', callback);\r\n\r\n    So far we haven't done anything with shotgun. We've just put together a small app the continually asks the user for input and then prints that input to the console.\r\n\r\n    > prompt: cmdStr: test  \r\n    > Echo: test\r\n\r\n3. Once you have a proper prompt application setup go ahead and install shotgun.\r\n    > npm install shotgun\r\n\r\n4. Require shotgun and instantiate a shell.\r\n\r\n        var prompt = require('prompt'),\r\n            shotgun = require('shotgun'),\r\n            shell = new shotgun.Shell();\r\n\r\n        function callback(err, val) {\r\n            if (!err && val.cmdStr) {\r\n                console.log(\"Echo: \" + val.cmdStr);\r\n            }\r\n            prompt.get('cmdStr', callback);\r\n        }\r\n        prompt.get('cmdStr', callback);\r\n\r\n5. Now that you have an instance of the shell you can begin to pass the user's value into the `execute()` function.\r\n\r\n        var prompt = require('prompt'),\r\n            shotgun = require('shotgun'),\r\n            shell = new shotgun.Shell();\r\n\r\n        function callback(err, val) {\r\n            var result = {};\r\n            if (!err && val.cmdStr) {\r\n                result = shell.execute(val.cmdStr);\r\n            }\r\n            prompt.get('cmdStr', callback);\r\n        }\r\n        prompt.get('cmdStr', callback);\r\n\r\n6. So far all we've done is pass the user's input on to shotgun and get back a `result` object, but we're not yet using it for anything. The `result` object returned from shotgun acts as a set of instructions. Depending on the command modules installed the result object could contain a wide variety of properties for you to consume in your application. There are a few default commands that come with shotgun: clear, exit, and help. 'clear' sets a property on the result called `clearDisplay`. 'exit' sets a property on the result called `exit`. 'help' writes a bunch of objects to a `lines` array on the result object. The lines array will always contain an array of objects, each object representing a single line of text. This is how shotgun stays UI agnostic because the app using shotgun can iterate over this array and display each line however it chooses to. Let's write some code to handle each of these situations:\r\n\r\n        var prompt = require('prompt'),\r\n            shotgun = require('shotgun'),\r\n            shell = new shotgun.Shell();\r\n\r\n        function callback(err, val) {\r\n            var result = {},\r\n                exit = false;\r\n            if (!err && val.cmdStr) {\r\n                result = shell.execute(val.cmdStr);\r\n\r\n                if (result.clearDisplay) {\r\n                    for(var i = 0; i < 50; i++) {\r\n                        console.log('\\r\\n');\r\n                    }\r\n                }\r\n\r\n                exit = result.exit;\r\n\r\n                result.lines.forEach(function (line) {\r\n                    console[line.type](line.text);\r\n                });\r\n            }\r\n            if (!exit) {\r\n                prompt.get('cmdStr', callback);\r\n            }\r\n        }\r\n        prompt.get('cmdStr', callback);\r\n\r\n    In the above example we do several things. First we check if `clearDisplay` is true. If it is then we print a bunch of blank lines to the display. Next we check if `exit` is true and if it is then we skip calling the prompt module and let the application exit. Lastly we iterate over the `lines` array. Each line object has a `type` property and a `text` property. Obviously `text` contains the text for that line; `type` contains either 'log', 'warn', or 'error' as it's value. You can do whatever you choose with that value but in this example I decided to map that to the functions with the same name on the `console`, passing in the `text`.\r\n\r\n7. We're almost done but there is one more piece we need to include. To maintain state across executions shotgun hands back a context object. `result.context` contains information that allows shotgun to know if it was prompting the user for a value, among other things. You are welcome to examine this object in more detail, but the only thing you are required to do with it is pass it back in on each execution. To do this in our sample app we will create a `context` variable in a higher scope and update that with the value from `result`.\r\n\r\n        var prompt = require('prompt'),\r\n            shotgun = require('shotgun'),\r\n            shell = new shotgun.Shell(),\r\n            context = {};\r\n\r\n        function callback(err, val) {\r\n            var result = {},\r\n                exit = false;\r\n            if (!err && val.cmdStr) {\r\n\r\n                // execute takes the user input string, an optional 'options' object, and the 'context' object we mentioned.\r\n                result = shell.execute(val.cmdStr, {}, context);\r\n\r\n                context = result.context;\r\n\r\n                if (result.clearDisplay) {\r\n                    for(var i = 0; i < 50; i++) {\r\n                        console.log('\\r\\n');\r\n                    }\r\n                }\r\n\r\n                exit = result.exit;\r\n\r\n                result.lines.forEach(function (line) {\r\n                    console[line.type](line.text);\r\n                });\r\n            }\r\n            if (!exit) {\r\n                prompt.get('cmdStr', callback);\r\n            }\r\n        }\r\n        prompt.get('cmdStr', callback);\r\n\r\n    Now our context object is traveling in a loop as we execute commands. Every time we execute a command we save the context and pass it back in with the next execution. If you were to use shotgun in a web application you would either need to send it to the client and then have the client send it back with the next request, or you would need to store it in session.\r\n\r\nThat's it, you're done with your first little shotgun app!\r\n\r\n---\r\n\r\n## Creating a Shotgun Command Module\r\n\r\nShotgun command modules are just Node modules. There isn't anything special about them except that they must define a specific function called 'invoke'.\r\n\r\n    // cmds/echo.js\r\n\r\n    // The invoke function is where the command logic will go.\r\n    exports.invoke = function (options, shell) {\r\n        var res = this;\r\n        var iterations = options.iterations;\r\n        for (var count = 0; count < iterations; count++) {\r\n            res.log(options.message);\r\n        }\r\n    };\r\n\r\nWithin the `invoke` function two parameters are passed in for you to use. The first is `options` which simply stores all the user-supplied options when invoking your command. The second option is the instance of the shotgun `shell`. The shell allows you to access other command modules via the `cmds` collection.\r\n\r\nIn the body of the `invoke` function you also have access to a *result API* via the `this` keyword. As in the above example you may want to assign `this` to a variable in case you define your own functions within `invoke` where `this` would refer to a different scope. Within `invoke` the `this` keyword refers to a result object with some helper functions defined for you.\r\n\r\n### Helper Functions\r\n\r\nThe result object's helper functions are as follows:\r\n\r\n`log` - Adds a line of text to the `lines` array on the result object.\r\n`warn` - Same as `log` except it changes the line's `type` property to \"warn\".\r\n`error` - Same as `warn` except `type` is set to \"error\".\r\n\r\n`warn` and `error` are useful for giving context to lines of text so that the UI can apply different styling behaviors when displaying the text to the user. For example your command might do something like `this.warn('The value supplied is below the minimum threshold.');` within the `invoke` function. This adds a line object to the `lines` array on the result object that will be passed to the application using shotgun. When the application iterates over the `lines` array it will see that the line has a property called `type` that is set to \"error\" and it will know to display the text differently from the normal `log` type.\r\n\r\nThere are two other helper functions available known as `setContext` and `resetContext` but we'll go into more detail with those later in this README.\r\n\r\n### Optional Command Properties\r\n\r\nCommand modules may also expose any of three other properties.\r\n\r\n    // cmds/echo.js continued\r\n\r\n    // A string containing a short description of the command.\r\n    exports.description = 'Displays the supplied message.';\r\n\r\n    // A string containing helpful usage syntax for the user.\r\n    exports.usage = '<message> [options]';\r\n\r\n    // Options is an object containing a comprehensive list of parameters that the command accepts and understands.\r\n    exports.options = {\r\n        message: {\r\n            noName: true,\r\n            required: true,\r\n            description: 'The message to be displayed.',\r\n            prompt: true\r\n        },\r\n        iterations: {\r\n            aliases: ['i'],\r\n            required: true,\r\n            default: 1,\r\n            description: 'The number of times to display the message.',\r\n            validate: /^[1-9]\\d*$/\r\n        }\r\n    };\r\n\r\nAny options specified in the user input will be passed to the `invoke()` function of the command regardless of whether or not they appear in the command's `options` property. The `options` property is used to validate specific options that the command understands. For instance, in the above example we provided a regular expression to the validation property on the iterations option. You may also supply a function to the validate property if you need more customized validation.\r\n\r\n    iterations: {\r\n        aliases: ['i'],\r\n        required: true,\r\n        default: 1,\r\n        description: 'The number of times to display the message.',\r\n        validate: function (value) {\r\n            return value > 0;\r\n        }\r\n    }\r\n\r\nWhen you define options with `noName` set to true, such as the message option in the above example, that lets shotgun know that this option will have no hyphenated name provided in the user input. Options without names will be added to the `options` object that is passed to the command's `invoke()` function in the order they are found in the parsed user input. For example:\r\n\r\n    echo \"Dance monkey, dance!\" -i 5\r\n\r\nUsing the sample 'echo' command we defined earlier the above sample user input would yield the following:\r\n\r\n    // cmds/echo.js\r\n\r\n    exports.invoke = function (options, shell) {\r\n        options.iterations == 5; // true\r\n        options.message == \"Dance monkey, dance!\"; // true\r\n    };\r\n\r\nSince the `message` option has `noName` set to true shotgun simply parses the user input and adds first non-named option to the options object under `message`. The order matters if the option has `noName` enabled.\r\n\r\nI stated earlier that named options are passed to the command even if they are not defined in the `options` property of that command. Thus, the following is valid:\r\n\r\n    echo \"Dance monkey, dance!\" -i 5 --verbose\r\n\r\nwould yield:\r\n\r\n    // cmds/echo.js\r\n\r\n    exports.invoke = function (options, shell) {\r\n        options.verbose == true; // true\r\n    };\r\n\r\nDespite `verbose` not being defined as part of the `options` property, it is still accessible if provided by the user. It will just be optional and won't undergo any validation.\r\n\r\n### Defined Command Options\r\n\r\nAs explained above, the user can supply any option they wish and your command module could access that value via the supplied `options` object. Defining `exports.options` on your command module is just a way to tell shotgun what options your module understands and what rules to apply to those options if they are found. Here is a comprehensive list of available properties you can set for each option you define for your command module:\r\n\r\n#### aliases\r\n\r\n    exports.options = {\r\n        message: {\r\n            aliases: ['m', 'msg']\r\n        }\r\n    };\r\n\r\nSometimes you may not want the user to have to type `--message` as a parameter for your command every single time. You can supply aliases so that the user can supply one of the aliases instead. In the above example the user could supply `-m` or `--msg` instead of `--message` if they chose to.\r\n\r\n#### default\r\n\r\n    exports.options = {\r\n        message: {\r\n            default: 'Hello World'\r\n        }\r\n    };\r\n\r\nDefining options with a default value ensures that the option will have a value even if the user does not supply one. In the above example the user could supply a message, but if they don't then the default value of \"Hello World\" would be used.\r\n\r\n#### description\r\n\r\n    exports.options = {\r\n        message: {\r\n            description: \"A message to be displayed.\"\r\n        }\r\n    };\r\n\r\nYou don't have to supply a description, but if you do then it will show up when the user attempts to get help information for the command by typing `help commandName`.\r\n\r\n#### noName\r\n\r\n    exports.options = {\r\n        message: {\r\n            noName: true\r\n        }\r\n    };\r\n\r\nSupplying `noName: true` tells shotgun that this option does not have to be specified by name. For example, the user could supply `\"some value\"` instead of `--message \"some value\"`. Keep in mind that options with no name are evaluated in order. If you have two options with `noName: true` then the first user-supplied value without a name will be used for the first option you defined and the second user-supplied value with no name will be used for the second option. The order does not matter when options are supplied with a name, even if `noName` is true.\r\n\r\n#### password\r\n\r\n    exports.options = {\r\n        message: {\r\n            password: true\r\n        }\r\n    };\r\n\r\nSetting `password: true` only has an effect if a `prompt` is also set. This tells shotgun to set `result.password = true;` on the result object. If the UI chooses to it could use this password property to modify the UI input field to be a password field for the prompt. This is useful for a login command where the command will prompt the user for their password.\r\n\r\n#### prompt\r\n\r\n    exports.options = {\r\n        message: {\r\n            prompt: true // or prompt: 'Enter a message.'\r\n        }\r\n    };\r\n\r\nIf you specify `prompt: true` on your option then the user will be prompted for the value if they do not supply it themselves. If `prompt` is set to true then it will prompt the user with a default message like \"Enter value for message.\" You also have the option to supply your own message by simply replacing `true` with a string. The supplied string will be displayed instead of the default message.\r\n\r\n#### required\r\n\r\n    exports.options = {\r\n        message: {\r\n            required: true\r\n        }\r\n    };\r\n\r\nThis is one of the simpler options. If you set `required: true` on an option then shotgun will display an error to the user if they do not supply a value. One caveat is if you supply a default value or a prompt because either the default value will be used if there is no user-supplied value or the user will be prompted for the value.\r\n\r\n#### validate\r\n\r\n    exports.options = {\r\n        message: {\r\n            validate: // Regular expression or function that accepts a value and returns true or false.\r\n        }\r\n    };\r\n\r\nValidate allows you to specify a regular expression or a function that will inform shotgun that the supplied value should be validated. If the value does not pass validation then an error will be displayed to the user and they will have to supply valid input before the command will be invoked.\r\n\r\n### Our example 'echo' command\r\n\r\nWhat we did in a previous example is create a simple command called 'echo' that will be plugged into the shotgun shell framework simply by placing the module in the 'cmds' directory (or the directory you passed into the shell).\r\n\r\nThe example command we just wrote is a pretty simple command. It performs a small task and only accepts one option. The nice thing about shotgun is that you don't have to do any pre-parsing of user input before passing it along to the module. Shotgun does all the legwork for you, allowing you to focus on creating well-designed command modules instead of worrying about user input, context, etc.\r\n\r\n    var result = shell.execute('echo -i 5 \"Hello world!\"');\r\n    console.log(result);\r\n\r\nThis would yield:\r\n\r\n    {\r\n        context: {},\r\n        clearDisplay: false,\r\n        lines: [\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'Hello world!'\r\n            },\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'Hello world!'\r\n            },\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'Hello world!'\r\n            },\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'Hello world!'\r\n            },\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'Hello world!'\r\n            }\r\n        ]\r\n    }\r\n\r\nThe lines are contained in an array. Each line object contains the text that will be displayed for that line and an `options` object containing meta information about the line such as bold, italic, underline, etc. charByChar is true by default; it tells the UI that if it can it should print out the line character by character to give it that movie-style terminal feel. The UI can then apply whatever display options it is capable of providing, but the options can be safely ignored if necessary. For example, if you were writing a console application then bold, italics, and underline wouldn't be possible. The options are just metadata that does not have to be used.\r\n\r\n### The 'help' command\r\n\r\nShotgun has a few built-in commands and one of those is 'help'. When the help command is specified by itself it lists all the available commands and their description message. The help command also accepts an argument, the name of a specific command. If a specific command is specified then the help command will print the command, its usage syntax, its description, and list all the defined available options (if any) for the command.\r\n\r\nThe shell instance has an execute function. This is the primary entry point into the shotgun module. It takes in a command line string, parses it appropriately, and returns a result object.\r\n\r\n    var result = shell.execute('help');\r\n    console.log(result);\r\n\r\nThis would yield:\r\n\r\n    {\r\n        context: {},\r\n        clearDisplay: false,\r\n        lines: [\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'clear        Clears the display.'\r\n            },\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'echo         Displays the supplied text for a specified number of times.'\r\n            }\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'exit         Exits the application.'\r\n            },\r\n            {\r\n                options: { charByChar: true },\r\n                type: 'log',\r\n                text: 'help         Displays general help info or info about a specific command.'\r\n            }\r\n        ]\r\n    }\r\n\r\n### The `invoke` function and the result object.\r\n\r\nThe `shell.execute()` function always returns a result object. You may have noticed in our example command above that this object gets passed into the `help` and `invoke` functions. You are allowed to add any properties you wish to this object, though it is not recommended that you overwrite this object altogether as shotgun will add context information to it for you; if you overwrite this object you will lose this information.\r\n\r\nThe result object contains helper functions. While you could manually push an object to the lines array on the result object, it is far more convenient to use the provided helper functions. Below is an example of using the `log()` function.\r\n\r\n    exports.invoke = function (options, shell) {\r\n        this.log('This is an example of using the log() function.');\r\n    };\r\n\r\nSome functions, such as `log()` take an options object if needed. In the case of `log()` this object is added to each line object in the lines array.\r\n\r\n    exports.invoke = function (options, shell) {\r\n        this.log('If possible, the UI should display this line bolded, italicized, and underlined.', {\r\n            bold: true,\r\n            italic: true,\r\n            underline: true\r\n        });\r\n    };\r\n\r\nThere are standard properties that shotgun always adds to the result object such as `context`, `lines`, `clearDisplay`, and `exit`. You can change these options when necessary, but you are also welcome to add your own values.\r\n\r\n    // cmds/mycommand.js\r\n\r\n    exports.invoke = function (options, shell) {\r\n        this.customMessage = 'This is a custom message.';\r\n    };\r\n\r\n    // app.js\r\n\r\n    console.log(shell.execute('mycommand').customMessage);\r\n\r\n`shell.execute` also takes an options object in case you need to make values available to a command without them needing to be supplied as user input.\r\n\r\n    // app.js\r\n\r\n    shell.execute('mycommand', { someValue: true });\r\n\r\n    // cmds/mycommand.js\r\n\r\n    exports.invoke = function (options, shell) {\r\n        this.log('Custom value: ' + options.someValue);\r\n    };\r\n\r\nValues supplied in this manner will override user input that matches it, so be mindful of the options you pass in. For example:\r\n\r\n    // app.js\r\n\r\n    shell.execute('mycommand --someValue \"pizza\"', { someValue: 'bacon' });\r\n\r\nwill yield:\r\n\r\n    // cmds/mycommand.js\r\n\r\n    exports.invoke = function (options, shell) {\r\n        options.someValue; // 'bacon'\r\n    };\r\n\r\n### Setting a helpful command context.\r\n\r\nCommand contexts are extremely helpful and save the user a lot of keystrokes. Basically a command context is a state that tells shotgun to pass all supplied values to the command in the context. It will be easier to illustrate this concept with an example. Let's say you are authoring a 'topic' command module. This command is responsible for showing a topic on a forum board. To execute this command the user would supply a topic ID to the command like 'topic 123' and the command would display the content of the forum topic with ID 123. Now let's say the user wants to reply to topic 123 and in order to do that you've setup a '-r' option that will prompt them for their reply text. The user's experience would go something like this:\r\n\r\n> $ topic 123  \r\n> [displays topic content]  \r\n> $ topic 123 -r  \r\n> Please enter your reply.\r\n\r\nThe user is forced to type the entire 'topic 123' command over again just so he/she can supply the '-r' flag. With command contexts your topic command can simply do this:\r\n\r\n    this.setContext('topic 123');\r\n\r\nThis simple helper will setup a command context. Now all the user's input will be appended to that context. The new user experience will be something like this:\r\n\r\n> $ topic 123  \r\n> [displays topic content]  \r\n> $ -r  \r\n> Please enter your reply.\r\n\r\nThe full command is expanded out to 'topic 123 -r' because shotgun knows that 'topic 123' is the current context. How does the user clear the context you ask? They don't have to! If the supplied input from the user matches another command then shotgun will disregard the context and execute that command. If that command creates a different context then it will override the previous context. If that command does not create a new context then the context will be restored after the command is finished. Basically this means a user experience like the following is possible:\r\n\r\n> $ topic 123  \r\n> [displays topic content]  \r\n> $ help topic  \r\n> [displays help for the topic command]  \r\n> $ -r  \r\n> Please enter your reply.\r\n\r\nNotice how the user was able to run the 'help' command after the 'topic 123' context was set. When the 'help' command finished the user was still able to supply just the '-r' because the context was still active. The default 'clear' command resets the active context but if you do need to clear the active context anywhere else in your command modules then you can run the following helper:\r\n\r\n    this.resetContext();\r\n",
  "bugs": {
    "url": "https://github.com/Chevex/node-shotgun/issues"
  },
  "_id": "shotgun@2.0.0",
  "dist": {
    "shasum": "660b1bc12cad4eb07188086d922ac3e82e8a8f94"
  },
  "_from": "shotgun@2.0.0",
  "_resolved": "https://registry.npmjs.org/shotgun/-/shotgun-2.0.0.tgz"
}
